module example

import data/list as l

type A {
   A(i32)
   B(i32)
}

fun test() : state<i32> unit {
   val a = get<i32>()
   set(a+1)
}

fun test2<a>(a: a) : a {
   a
}

impl fun test2(a:i32) : i32 {
   a + 33
}

fun test_branch(a:i32) : [nodet<i32>] i32 {
   var b = 10
   if (branch(a)) {
      b = b + a + 1
   } else {
      b = b + a + 2
   }
   b
}

fun test_inline() : io unit {
   inline_python<unit>("print(\"test_inline\")")
}

fun main() : io unit {
  var a = 0
  val A(b) = A(2)

  val l = l/Cons(3, l/Cons(2, l/Cons(1, l/Nil<i32>)))

  val ll = l/map(l, fn(a:i32) : io i32{
     print(a)
     a + 1
  })

  val t0 = tensor<i32, [4, 4]>
  val t1 = tensor<i32, [4, 8]>

  [t2[i, j] += t0[i+r, j+s] * t1[r, s]] : tensor<i32, [2, 2]>

  print(handle nodet<i32> {
     handle state<i32> {
        test()
        test()
        test()
        test_branch(50)
     } with {
        fun get() {
           resume(a)
        }
        fun set(v:i32) {
           a = v
           print(a)
           resume(unit)
        }
     }
  } with {
     fun branch(a:i32) {
        resume(false) + resume(true)
     }
  })
  print(if a > 10 {
     print(10000)
     100
  } else {
     print(1000000)
     1000
  })
  while a < 10 {
    print(a)
    a = a + 1
    unit
  }

  case A(200) {
     A(a) -> {print(a)}
     B(3) -> {print("bbbb")}
  }

  print(test2(a))
  val f = fn () : i32 { a + 1 }
  print(f())
  print(a)
  test_inline()
}

