module data/list

type list<a> {
  Nil
  Cons(a, list<a>)
}

fun reverse<a>(l : list<a>) : list<a> {
  var rest = l
  var newl = Nil<a>
  while (rest != Nil<a>) {
    val Cons(e, r) = rest
    rest = r
    newl = Cons(e, newl)
  }
  newl
}

fun map<a, b>[e](l : list<a>, f : (a) -> e b) : e list<b> {
  if l == Nil<a> {
    Nil<b>
  } else {
  val Cons(e, r) = l
    if r == Nil<a> {
      Cons(f(e), Nil<b>)
    } else {
      Cons(f(e), map(r, f))
    }
  }
}